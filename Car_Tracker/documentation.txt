I have three source files in this project which are Car.java holds the car objects, the IndexMinPQ.java is adapted from the book code, and the driver program CarTracker.java. cars.txt is the test file for the CarTracker.java.
There are four indexable double priority queue data structure initialized at the beginning of the driver program depending on the choosing priority, if choosing priority is car’s price then the regular IndexMinPQ is constructed with size of the table, I used 101 in the program since 101 is a prime number by using the compardTo() method implemented of the Comparable interface, if the choosing priority is car’s mileage the IndexMinPQ is constructed by the table size(101) and the comparator.
By the testing purpose, the driver program first read in the test file cars.txt. Inserting into the four different priority queue data structure. For the operation i) Add a car , the car will be inserted to the priority queue object pq upon the priority of their price, the lowest price will be stored in the index 1. The car object is inserted in to pq with their unique hash value which computed primarily by their unique VIN number. The pq array holds the cars hash values and heapfy the cars order by their price value. Than the car objects are inserted into the keys array by their hash value. The keys array is indexed by the hash values of the cars. The qp array is the inverse of pq array, qp also indexed with the car objects hash value.
ii) Update the specified car 
The three main steps to update a car are: 1) find the car by their hash value as the index of keys array 2)update the car’s information by settor functions 3)reheaping the pq by the car’s price.
iii) Remove the specified car
First find the car by it’s hash value in the keys array, then remove the car from the pq ,reheap the priority queue.
iv) Retrieve the  lowest price car
Return the keys[pq[1]] object, since pq[1] stores the hashvalue of lowest car, so keys[pq[1]] stores the lowest price car object.
v) Retrieve the lowest mileage car
Return the keys[pqMile[1]], similar theory with the previous operation, but the pqMile is heapfied by the mileage comparator of each car rather than compareTo method in the pq.
vi) Retrieve the lowest price car by make and model
The IndexMinPQ.java file has used the linear probe solution for hashing collision for the same hash value computed by the same make and model. The pq data structure still holds the hash values of each car’s hash value but since the same make and model will generate same hash value there will be collisions when insert into the actual object holding array, keys[].
For solving this problem, the insertHash() method in the IndexMinPQ.java used linear probe to find the next empty spot for the same hash value item in the keys[] array. For finding the lowest price, the getLowPrice() method in the IndexMinPQ.java use the same theory to linear probe and find the lowest car’s price by linear search. The inserting and retrieve process both need Big O of N runtime where N is the number of cars. The space requirement is at least double size of the items of the number of objects to keep the loading factor is 50%. So in the insertHash() method the table will be double sized when the loading factor is 50%.
vii) Retrieve the lowest mileage car by make and model
This operation is similar to the previous one and using the same insertHash() method , the differences are inserting into the different priority queue pqMakeModelByMile using the comparator compare mile to maintain the priority order , and retrieve the lowest mileage are by getLowMile().

